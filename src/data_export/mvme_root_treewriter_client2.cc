#include <getopt.h>
#include <string>

// ROOT
#include <TFile.h>
#include <TROOT.h>

// mvme
#include <Mustache/mustache.hpp>
#include "mvme_data_server_lib.h"
#include "data_export/mvme_root_export_objects.h"

using std::cout;
using std::endl;

namespace mu = kainjow::mustache;
using namespace mvme::data_server;

//
// ClientContext
//
class ClientContext: public mvme::data_server::Parser
{
    protected:
        virtual void serverInfo(const Message &msg, const json &info) override;
        virtual void beginRun(const Message &msg, const StreamInfo &streamInfo) override;

        virtual void eventData(const Message &msg, int eventIndex,
                                const std::vector<DataSourceContents> &contents) override;

        virtual void endRun(const Message &msg) override;

        virtual void error(const Message &msg, const std::exception &e) override;
};

//
// main
//
int main(int argc, char *argv[])
{
    // The impl and the header file have to be generated by mvme.
    // This file itself will also be generated by mvme.

    TFile f("test1.root", "recreate");

    // produces SnakeMVME_cxx.so and loads it immediately
    cout << gROOT->ProcessLineSync(".L SnakeMVME.cxx+") << endl;

    auto experiment = reinterpret_cast<Experiment *>(
        gROOT->ProcessLineSync("new SnakeExperiment();"));

    if (!experiment) return 1;

    cout << experiment->ClassName() << endl;

    auto trees = experiment->MakeTrees();

    assert(trees.size() == experiment->GetNumberOfEvents());

    f.Write();


#if 0
    // host, port, quit after one run?,
    // output filename? if not specified is taken from the runId
    // send out a reply is response to the EndRun message?
    std::string host = "localhost";
    std::string port = "13801";
    std::string outputDirectory = "./";
    bool singleRun = false;
    bool convertNaNs = false;
    bool showHelp = false;

    ClientContext ctx;

    while (true)
    {
        static struct option long_options[] =
        {
            { "single-run",             no_argument, nullptr,   0 },
            { "convert-nans",           no_argument, nullptr,   0 },
            { "output-directory",       no_argument, nullptr,   0 },
            { "help",                   no_argument, nullptr,   0 },
            { nullptr, 0, nullptr, 0 },
        };

        int option_index = 0;
        int c = getopt_long(argc, argv, "", long_options, &option_index);

        if (c == '?') // Unrecognized option
        {
            return 1;
        }

        if (c != 0)
            break;

        std::string opt_name(long_options[option_index].name);

        if (opt_name == "single-run")   singleRun = true;
        if (opt_name == "convert-nans") convertNaNs = true;
        if (opt_name == "output-directory") outputDirectory = argv[option_index];
        if (opt_name == "help")         showHelp = true;
    }

    if (showHelp)
    {
        cout << "Usage: " << argv[0]
            << " [--single-run] [--convert-nans] [host=localhost] [port=13801]"
            << endl << endl
            ;

        cout << "  If single-run is set the process will exit after receiving" << endl
             << "  data from one run. Otherwise it will wait for the next run to" << endl
             << "  start." << endl
             << endl
             << "  If convert-nans is set incoming NaN data values will be" << endl
             << "  converted to 0.0 before they are written to their respective ROOT" << endl
             << "  tree Branch." << endl
             << endl
             ;

        return 0;
    }
#endif

    return 0;
}
