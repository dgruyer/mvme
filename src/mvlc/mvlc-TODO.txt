* Change the Dialog code to handle notification buffers. These could either be emitted via
  signal if it's made a QObject or be stored in a notification buffer and queried by the
  user after a transaction (implement this first and if needed put a Qt layer on top).

* Where to do the locking? In some higher level layer and make sure that all communication
  goes through that layer?
  Or at the very lowest layer, the AbstractImpl? This could carry two locks, be changed to
  have protected virtuals for the implementation and do the locking in it's concrete
  public implementation.

  But this would still not solve the problem of having a sort of transaction lock for the
  dialog part.

  Should the dialog part be called "Session"? Protocol? Request/Response?

  => Do locking on a higher level layer. This way lower level code doesn't need to worry
  about locks if it's not threaded. Also the use case is not abstract but specific:
  Main (GUI) Thread
    MVLC connection
      - dialog operation for setup and immediate stack exec
        Users: vme init layer, vme debug widget, direct script exec, any tools actually
        using the mvlc :-)
        Can be done blocking in a batch program, should be done using QtConcurrent::run()
        or similar in a GUI application.
      - Periodic polling of the Command Pipe to read notifications.
      => One "Session" lock in the GUI app. Locked when doing Command Pipe transactions.

   Readout Thread:
     - Read-only operation on the Data Pipe. Long running.
     => One "Data Lock" in the GUI app.

   Global Operations on the MVLC: connect, disconnect and a combined (reconnect).
     - Requires that both the cmd and the data lock are held by the thread wanting to
       modify the underlying handles (one for ftd3xx, two for a UDP socket
       implementation).

* Build a tool to verify incoming readout data. Check headers and pointers. Test this with
  different incoming event sizes.
  For the first pass it's ok to do this offline.

* Refactor VMEConfigTreeWidget to not depend on MVMEContext anymore.


* add a vme script command for the WriteSpecial stack command
* test the Marker stack command

* Low Level MVLC Ethernet Debugging:

    ifconfig enp2s0 192.168.42.1 netmask 255.255.255.0 up
    arp -i enp2s0 -s 192.168.42.2 0a:0f:0f:0e:12:34

  Start wireshark or tcpdump in a second terminal window
    sudo tcpdump -i enp2s0 -vvXX

  Use netcat to generate an UDP packet containing "Hello, World!" as the payload.
    echo "Hello, world!" | netcat -u 192.168.42.2 9000

  To delete the arp entry:
    arp -i enp2s0 -d 192.168.42.2
