* Soft deadlock when doing 'auto guard = getLocks().lock(pipe);' in
  MVLCObject::getReadQueueSize().
  What's happening is that the readout thread quickly loops and holds the lock most of the
  time. In parallel the GUI thread wants to periodically poll the read queue size but gets
  stuck acquiring the lock. It can take a very long time before the GUI thread gets
  scheduled at the right time and is able to acquire the lock before the readout.
  A possible solution is outlined here using a ticket system:
  https://stackoverflow.com/a/6453925

* The windows usb::Impl::read() and the udp::Impl::read() calls can take longer than the
  user specified timeout as they are issuing multiple read/receive calls internally, each
  using the previously set timeout value. Document this behaviour and/or work around it by
  taking into account how much time has elapsed between each of the individual
  read/receive calls.

* Build a tool to verify incoming readout data. Check headers and pointers. Test this with
  different incoming event sizes.
  For the first pass it's ok to do this offline.

* Low Level MVLC Ethernet Debugging:

    ifconfig enp2s0 192.168.42.1 netmask 255.255.255.0 up
    arp -i enp2s0 -s 192.168.42.2 ab:cd:12:34:56:78

  Start wireshark or tcpdump in a second terminal window
    sudo tcpdump -i enp2s0 -vvXX

  Use netcat to generate an UDP packet containing "Hello, World!" as the payload.
    echo "Hello, world!" | netcat -u 192.168.42.2 9000

  To delete the arp entry:
    arp -i enp2s0 -d 192.168.42.2
